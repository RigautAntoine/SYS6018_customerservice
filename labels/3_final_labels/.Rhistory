trainHistory <- merge(trainHistory[,c("id", "offer")], offers[,c("offer", "dept")], by="offer", all.x=T)
names(trainHistory)[2] <- "ID"
transaction <- merge(transaction, trainHistory[,c("ID", "dept")], by="ID", all.x=T)
sum(is.na(transaction$dept))
transaction <- transaction[,names(transaction)[!(names(transaction) %in% c("offer_quantity", "ID"))]]
transaction[is.na(transaction)] <- 0
sum(is.na(transaction))
set.seed(1)
ind <- sample(1:nrow(transaction), nrow(transaction) * 0.7)
train <- transaction[ind,]
test <- transaction[-ind,]
fit <- glm(label~., data=train, family = "binomial")
transaction$never_bought_brand <- factor(transaction$never_bought_brand)
transaction$never_bought_category <- factor(transaction$never_bought_category)
transaction$never_bought_company <- factor(transaction$never_bought_company)
transaction$has_bought_company <- factor(transaction$has_bought_company)
transaction$has_bought_brand_category <- factor(transaction$has_bought_brand_category)
transaction$has_bought_brand_company <- factor(transaction$has_bought_brand_company)
transaction$has_bought_brand_company_category <- factor(transaction$has_bought_brand_company_category)
set.seed(1)
ind <- sample(1:nrow(transaction), nrow(transaction) * 0.7)
train <- transaction[ind,]
test <- transaction[-ind,]
fit <- glm(label~., data=train, family = "binomial")
transaction <- read.csv("project_aggregated_ds.csv", stringsAsFactors = F)
# We want to add the department of the product coupon as a categorical variable
# Load offers
offers <- read.csv('offers.csv', header = T)
# Department is the first two digits of category (if category is 4-digit) or the first digit (if category is 3-digit)
offers$dept <- as.factor(sapply(offers$category, function(x)ifelse(nchar(x) > 3, substr(x, 1, 2), substr(x, 1, 1))))
# Load trainHistory
trainHistory <- read.csv("trainHistory.csv")
# Merge to find for each customer id the department of the offer
trainHistory <- merge(trainHistory[,c("id", "offer")], offers[,c("offer", "dept")], by="offer", all.x=T)
names(trainHistory)[2] <- "ID"
# Now merge the transaction dataset with the obtained department variable
transaction <- merge(transaction, trainHistory[,c("ID", "dept")], by="ID", all.x=T)
transaction[, "dept"] <- factor(transaction$dept) # Remove unused factor level by simply calling factor on the var
# Get rid of customer id and offer quantity. We will not make use of these variables in the model
transaction <- transaction[,names(transaction)[!(names(transaction) %in% c("offer_quantity", "ID"))]]
# Missing values in this dataset are not really missing values. They are zero values.
transaction[is.na(transaction)] <- 0
# Transform into factor variable
transaction$never_bought_brand <- factor(transaction$never_bought_brand)
transaction$never_bought_category <- factor(transaction$never_bought_category)
transaction$never_bought_company <- factor(transaction$never_bought_company)
transaction$has_bought_brand_category <- factor(transaction$has_bought_brand_category)
transaction$has_bought_brand_company <- factor(transaction$has_bought_brand_company)
transaction$has_bought_brand_company_category <- factor(transaction$has_bought_brand_company_category)
set.seed(1)
ind <- sample(1:nrow(transaction), nrow(transaction) * 0.7)
train <- transaction[ind,]
test <- transaction[-ind,]
fit <- glm(label~., data=train, family = "binomial")
summary(fit) # Note that the department variable seems to play a significant role
t <- transaction[apply(transaction,1, function(x) any(x<0)),] # 305 customers with negative values
nrow(t)
t <- transaction[apply(transaction,1, function(x) any(x<0)),] # 305 customers with negative values
nrow(t)
t <- transaction[apply(transaction[,1:54],1, function(x) any(x<0)),] # 305 customers with negative values
nrow(t)
transaction <- read.csv("project_aggregated_ds.csv", stringsAsFactors = F)
transaction <- transaction[apply(transaction[,1:54],1, function(x) any(x<0)),] # 305 customers with negative values
transaction <- read.csv("project_aggregated_ds.csv", stringsAsFactors = F)
transaction <- transaction[apply(transaction,1, function(x) any(x<0) == F),] # 305 customers with negative values
transaction <- read.csv("project_aggregated_ds.csv", stringsAsFactors = F)
transaction[is.na(transaction)] <- 0
transaction <- transaction[apply(transaction,1, function(x) any(x<0) == F),] # 305 customers with negative values
transaction <- read.csv("project_aggregated_ds.csv", stringsAsFactors = F)
transaction[is.na(transaction)] <- 0
transaction <- transaction[apply(transaction,1, function(x) any(x<0) == F),] # 305 customers with negative values
offers <- read.csv('offers.csv', header = T)
offers$dept <- as.factor(sapply(offers$category, function(x)ifelse(nchar(x) > 3, substr(x, 1, 2), substr(x, 1, 1))))
trainHistory <- read.csv("trainHistory.csv")
# Merge to find for each customer id the department of the offer
trainHistory <- merge(trainHistory[,c("id", "offer")], offers[,c("offer", "dept")], by="offer", all.x=T)
names(trainHistory)[2] <- "ID"
# Now merge the transaction dataset with the obtained department variable
transaction <- merge(transaction, trainHistory[,c("ID", "dept")], by="ID", all.x=T)
transaction[, "dept"] <- factor(transaction$dept) # Remove unused factor level by simply calling factor on the var
# Get rid of customer id and offer quantity. We will not make use of these variables in the model
transaction <- transaction[,names(transaction)[!(names(transaction) %in% c("offer_quantity", "ID"))]]
# Transform into factor variable
transaction$never_bought_brand <- factor(transaction$never_bought_brand)
transaction$never_bought_category <- factor(transaction$never_bought_category)
transaction$never_bought_company <- factor(transaction$never_bought_company)
transaction$has_bought_brand_category <- factor(transaction$has_bought_brand_category)
transaction$has_bought_brand_company <- factor(transaction$has_bought_brand_company)
transaction$has_bought_brand_company_category <- factor(transaction$has_bought_brand_company_category)
boxplot(transaction$total_spend, ylab="total_spend") # % customers with more than 1mil spent
a <- boxplot(transaction$total_spend, ylab="total_spend") # % customers with more than 1mil spent
a$stats[5]
transaction <- transaction[transaction$total_spend < a$stats[5],]
boxplot(t$total_spend)
boxplot(transaction$total_spend, ylab="total_spend") # % customers with more than 1mil spent
hist(transaction$total_spend)
bin <- c("has_bought_brand_company", "label", "never_bought_category", "offer_value", "has_bought_brand_category", "has_bought_brand_company_category", "never_bought_brand", "never_bought_company")
transaction[,!(names(t) %in% bin)] <- sapply(transaction[,!(names(transaction) %in% bin)], function(x)log(x+1))
summary(transaction)
transaction <- read.csv("project_aggregated_ds.csv", stringsAsFactors = F)
# Missing values in this dataset are not really missing values. They are zero values.
transaction[is.na(transaction)] <- 0
# Get rid of negative records
transaction <- transaction[apply(transaction,1, function(x) any(x<0) == F),] # 305 customers with negative values
# We want to add the department of the product coupon as a categorical variable
# Load offers
offers <- read.csv('offers.csv', header = T)
# Department is the first two digits of category (if category is 4-digit) or the first digit (if category is 3-digit)
offers$dept <- as.factor(sapply(offers$category, function(x)ifelse(nchar(x) > 3, substr(x, 1, 2), substr(x, 1, 1))))
# Load trainHistory
trainHistory <- read.csv("trainHistory.csv")
# Merge to find for each customer id the department of the offer
trainHistory <- merge(trainHistory[,c("id", "offer")], offers[,c("offer", "dept")], by="offer", all.x=T)
names(trainHistory)[2] <- "ID"
# Now merge the transaction dataset with the obtained department variable
transaction <- merge(transaction, trainHistory[,c("ID", "dept")], by="ID", all.x=T)
transaction[, "dept"] <- factor(transaction$dept) # Remove unused factor level by simply calling factor on the var
# Get rid of customer id and offer quantity. We will not make use of these variables in the model
transaction <- transaction[,names(transaction)[!(names(transaction) %in% c("offer_quantity", "ID"))]]
# Transform into factor variable
transaction$never_bought_brand <- factor(transaction$never_bought_brand)
transaction$never_bought_category <- factor(transaction$never_bought_category)
transaction$never_bought_company <- factor(transaction$never_bought_company)
transaction$has_bought_brand_category <- factor(transaction$has_bought_brand_category)
transaction$has_bought_brand_company <- factor(transaction$has_bought_brand_company)
transaction$has_bought_brand_company_category <- factor(transaction$has_bought_brand_company_category)
boxplot(transaction$total_spend, ylab="total_spend") # % customers with more than 1mil spent
a <- boxplot(transaction$total_spend, ylab="total_spend")
transaction <- transaction[transaction$total_spend < a$stats[5],] # Remove the outliers
t <- transaction
hist(log(transaction$total_spend+1))
max(transaction$total_spend)
exp(6)
exp(7)
bin <- c("has_bought_brand_category",
"has_bought_brand_company_category",
"has_bought_brand_company",
"label",
"never_bought_category",
"never_bought_brand",
"never_bought_company")
transaction[,!(names(t) %in% bin)] <- sapply(transaction[,!(names(transaction) %in% bin)], function(x)log(x+1))
summary(transaction)
transaction <- t
bin <- c("has_bought_brand_category",
"has_bought_brand_company_category",
"has_bought_brand_company",
"label",
"never_bought_category",
"never_bought_brand",
"never_bought_company",
"dept")
transaction[,!(names(t) %in% bin)] <- sapply(transaction[,!(names(transaction) %in% bin)], function(x)log(x+1))
summary(transaction)
set.seed(1)
ind <- sample(1:nrow(transaction), nrow(transaction) * 0.7)
train <- transaction[ind,]
test <- transaction[-ind,]
fit <- glm(label~., data=train, family = "binomial")
summary(fit) # Note that the department variable seems to play a significant role
prob <- predict(fit, newdata = test, type = 'response')
pred <- ifelse(prob>0.5,1,0)
table(pred, test$label)
get.recall(pred, test$label) # Only 7% recall
get.accuracy(pred, test$label) # 74% accuracy
get.precision(pred, test$label) # 64% precision. It seems the classifier is conservative about classifying an
plot.ROC.curve(prob, test$label) # 0.64 in AUC
cost <- function(r, pi = 0) mean(abs(r-pi) > 0.5)
cv.glm(transaction, fit, cost, K=10)$delta[1] # Cross-validation error of about 25% with full model
dm <- data.matrix(transaction)
set.seed(1234)
train <- dm[ind,]
ind <- sample(1:nrow(transaction), nrow(transaction) * 0.7)
set.seed(1234)
ind <- sample(1:nrow(transaction), nrow(transaction) * 0.7)
train <- dm[ind,]
test <- dm[-ind,]
cv.lam <- cv.glmnet(train[,-32], factor(train[,32]), alpha=1, family="binomial", type.measure = "class")
plot(cv.lam)
bestlam <- cv.lam$lambda.min # best lambda as selected by cross validation
trainll <- glmnet(train[,-32], factor(train[,32]), alpha=1, family="binomial")
train[1:10, 32]
train[1:10, 33]
train[1:10, 34]
train[1:10, 31]
train[1:10, 30]
bestlam <- cv.lam$lambda.min # best lambda as selected by cross validation
probs <- predict(trainll, newx = test[,-32], s = bestlam, type="response")
plot.ROC.curve(probs, test[,32]) # Not much of an improvement
View(dm)
dm <- model.matrix(label~., data=transaction)
View(dm)
dm <- model.matrix(label~., data=transaction)[,-1]
View(dm)
set.seed(1234)
ind <- sample(1:nrow(transaction), nrow(transaction) * 0.7)
train <- dm[ind,]
test <- dm[-ind,]
cv.lam <- cv.glmnet(train, factor(transaction[ind, "label"]), alpha=1, family="binomial", type.measure = "class")
plot(cv.lam)
bestlam <- cv.lam$lambda.min # best lambda as selected by cross validation
trainll <- glmnet(train, factor(transaction[ind, "label"]), alpha=1, family="binomial")
probs <- predict(trainll, newx = test, s = bestlam, type="response")
plot.ROC.curve(probs, test[-ind, "label"]) # Not much of an improvement
plot.ROC.curve(probs, transaction[-ind, "label"]) # Not much of an improvement
source('C:/UVA/LinearModels/project/coupons.R')
write.csv(transaction, "Antoine_dataset.csv", row.names = F)
trainll.coef <- predict(trainll, type="coefficients", s=bestlam)
coef.df <- data.frame(word = unlist(trainll.coef@Dimnames[1]), as.matrix(trainll.coef))
coef.df <- data.frame(coefficients = unlist(trainll.coef@Dimnames[1]), as.matrix(trainll.coef))
View(coef.df)
coef.df <- data.frame(parameter = unlist(trainll.coef@Dimnames[1]), as.matrix(trainll.coef))
coef.df$parameter <- as.character(coef.df$parameter)
coef.df <- coef.df[coef.df$X1 != 0,]
coef.df <- coef.df[order(coef.df$X1, decreasing = T),]
View(coef.df)
nrow(coef.df)
table(transaction$dept)
plot(cv.lam)
plot.ROC.curve(probs, transaction[-ind, "label"]) # Not much of an improvement
set.seed(12)
ind <- sample(1:nrow(transaction), nrow(transaction) * 0.7)
train <- dm[ind,]
test <- dm[-ind,]
cv.lam <- cv.glmnet(train, factor(transaction[ind, "label"]), alpha=1, family="binomial", type.measure = "class")
plot(cv.lam)
bestlam <- cv.lam$lambda.min # best lambda as selected by cross validation
trainll <- glmnet(train, factor(transaction[ind, "label"]), alpha=1, family="binomial")
probs <- predict(trainll, newx = test, s = bestlam, type="response")
plot.ROC.curve(probs, transaction[-ind, "label"]) # Not much of an improvement
set.seed(100)
ind <- sample(1:nrow(transaction), nrow(transaction) * 0.7)
train <- dm[ind,]
test <- dm[-ind,]
cv.lam <- cv.glmnet(train, factor(transaction[ind, "label"]), alpha=1, family="binomial", type.measure = "class")
plot(cv.lam)
bestlam <- cv.lam$lambda.min # best lambda as selected by cross validation
trainll <- glmnet(train, factor(transaction[ind, "label"]), alpha=1, family="binomial")
probs <- predict(trainll, newx = test, s = bestlam, type="response")
plot.ROC.curve(probs, transaction[-ind, "label"]) # Not much of an improvement
set.seed(1000)
ind <- sample(1:nrow(transaction), nrow(transaction) * 0.7)
train <- dm[ind,]
test <- dm[-ind,]
cv.lam <- cv.glmnet(train, factor(transaction[ind, "label"]), alpha=1, family="binomial", type.measure = "class")
plot(cv.lam)
bestlam <- cv.lam$lambda.min # best lambda as selected by cross validation
trainll <- glmnet(train, factor(transaction[ind, "label"]), alpha=1, family="binomial")
probs <- predict(trainll, newx = test, s = bestlam, type="response")
plot.ROC.curve(probs, transaction[-ind, "label"]) # Not much of an improvement
View(probs)
test <- createFolds(dm, k=5)
library(caret)
test <- createFolds(dm, k=5)
str(test)
folds <- createFolds(transaction, k=10)
str(folds)
folds <- createFolds(1:nrow(transaction), k = 10)
dm <- model.matrix(label~., data=transaction)[,-1]
get.auc <- function(probs, labels){
preds <- prediction(probs, labels)
perf <- performance(preds, measure = "tpr", x.measure = "fpr")
auc <- performance(preds, measure = "auc")
return(auc@y.values[[1]])
}
auc <- rep(0, 10)
t <- c(folds[1:9])
t <- unlist(folds[1:9])
t[1:10]
t <- unlist(folds[1:2])
length(t)
t[13202]
t[13203]
i =1
train.ind <- unlist(folds[-i])
test.ind <- unlist(folds[-i])
test.ind <- unlist(folds[i])
length(test.ind)
test.ind[1]
train <- dm[train.ind,]
test <- dm[test.ind,]
cv.lam <- cv.glmnet(train, factor(transaction[train.ind, "label"]), alpha=1, family="binomial", type.measure = "class")
plot(cv.lam)
bestlam <- cv.lam$lambda.min # best lambda as selected by cross validation
trainll <- glmnet(train, factor(transaction[train.ind, "label"]), alpha=1, family="binomial")
probs <- predict(trainll, newx = test, s = bestlam, type="response")
auc <- c(auc, get.auc(probs, transaction[test.ind, "label"])) # Not much of an improvement
auc <- c()
auc <- c(auc, get.auc(probs, transaction[test.ind, "label"])) # Not much of an improvement
auc <- c()
for (i in 1:10) {
train.ind <- unlist(folds[-i])
test.ind <- unlist(folds[i])
train <- dm[train.ind,]
test <- dm[test.ind,]
cv.lam <- cv.glmnet(train, factor(transaction[train.ind, "label"]), alpha=1, family="binomial", type.measure = "class")
plot(cv.lam)
bestlam <- cv.lam$lambda.min # best lambda as selected by cross validation
trainll <- glmnet(train, factor(transaction[train.ind, "label"]), alpha=1, family="binomial")
probs <- predict(trainll, newx = test, s = bestlam, type="response")
auc <- c(auc, get.auc(probs, transaction[test.ind, "label"])) # Not much of an improvement
}
auc
mean(auc))
mean(auc)
View(transaction)
load("C:/UVA/DataMining/SYS6018_customerservice/script/logisticRegression.RData")
library(tm)
library(stringr)
library(slam)
library(glmnet)
library(ROCR)
library(ggplot2)
plot.ROC.curve <- function(probs, labels){
preds <- prediction(probs, labels)
perf <- performance(preds, measure = "tpr", x.measure = "fpr")
auc <- performance(preds, measure = "auc")
auc <- auc@y.values[[1]]
roc.data <- data.frame(fpr=unlist(perf@x.values),
tpr=unlist(perf@y.values),
model="GLM")
ggplot(roc.data, aes(x=fpr, ymin=0, ymax=tpr)) +
geom_ribbon(alpha=0.2) +
geom_line(aes(y=tpr)) +
ggtitle(paste0("ROC Curve w/ AUC=", auc))
}
setwd("C:/UVA/DataMining/SYS6018_customerservice/labels/3_final_labels")
tweets <- read.csv("trainData.csv", stringsAsFactors = T)
# Get the sentiment scores
scores <- read.csv("sentimentScores.csv", stringsAsFactors = F)
names(scores)[5] <- "sentiment"
scores <- scores[,c("text", "industry", "sentiment", "complaint")]
# Naive model
set.seed(1)
ind <- sample(nrow(scores), 3000)
naive.train <- scores[ind,]
naive.test <- scores[-ind,]
naive <- glm(complaint~sentiment, data=naive.train, family = "binomial")
summary(naive)
naive.probs <- predict(naive, newdata = naive.test, type = "response")
plot.ROC.curve(naive.probs, naive.test$complaint)
plot(perf, col="red", main = "ROC curve")
plot(air.perf, add = TRUE, col="green")
plot(tel.perf, add = TRUE, col="blue")
plot.ROC.curve(probs, test[,1])
library(AUC)
install.packages("AUC")
plot.CV.ROC.curve = function(probs, labels, k){
ROC <- function(i){
preds <- prediction(probs, labels)
perf <- performance(preds, measure = "tpr", x.measure = "fpr")
auc <- performance(preds, measure = "auc")
auc <- auc@y.values[[1]]
return(list(roc=cbind(unlist(perf$x.values),unlist(perf$y.values)),
auc=auc))
}
plot(0:1,0:1,col="white",xlab="",ylab="")
for(i in 1:k){
lines(ROC(i)$roc,type="s",col=CL[i])
#legend(.8,.45,name_var,col=CL,lty=1,cex=.8)
}
}
plot.CV.ROC.curve(naive.probs, naive.test$complaint, 10)
ROC <- function(probs, labels){
preds <- prediction(probs, labels)
perf <- performance(preds, measure = "tpr", x.measure = "fpr")
auc <- performance(preds, measure = "auc")
auc <- auc@y.values[[1]]
return(list(roc=cbind(unlist(perf$x.values),unlist(perf$y.values)),
auc=auc))
}
c <- ROC(naive.probs, naive.test$complaint)
probs =  naive.probs
labels <- naive.test$complaint
preds <- prediction(probs, labels)
perf <- performance(preds, measure = "tpr", x.measure = "fpr")
auc <- performance(preds, measure = "auc")
auc <- auc@y.values[[1]]
unlist(perf$x.values)
list(roc=cbind(unlist(perf@x.values),unlist(perf@y.values)),
auc=auc)
c <- ROC(naive.probs, naive.test$complaint)
ROC <- function(probs, labels){
preds <- prediction(probs, labels)
perf <- performance(preds, measure = "tpr", x.measure = "fpr")
auc <- performance(preds, measure = "auc")
auc <- auc@y.values[[1]]
return(list(roc=cbind(unlist(perf@x.values),unlist(perf@y.values)),
auc=auc))
}
c <- ROC(naive.probs, naive.test$complaint)
library(caret)
data = scores
folds <- createFolds(1:nrow(data), k)
k = 10
folds <- createFolds(1:nrow(data), k)
i = 1
train <- data[folds[-i],]
train <- data[unlist(folds[-i]),]
test <- data[unlist(folds[i]),]
ROC <- function(probs, labels){
preds <- prediction(probs, labels)
perf <- performance(preds, measure = "tpr", x.measure = "fpr")
auc <- performance(preds, measure = "auc")
auc <- auc@y.values[[1]]
return(list(roc=cbind(unlist(perf@x.values),unlist(perf@y.values)),
auc=auc))
}
train <- data[unlist(folds[-i]),]
test <- data[unlist(folds[i]),]
fit <- glm(formula, data=train, family = "binomial")
formula = complaint~sentiment
fit <- glm(formula, data=train, family = "binomial")
summary(fit)
fit.probs <- predict(fit, newdata = test, type = "response")
ROC(fit.probs, test[,"complaint"], i)
ROC(fit.probs, test[,"complaint"])
plot.CV.ROC.curve = function(formula, data, k){
folds <- createFolds(1:nrow(data), k)
plot(0:1,0:1,col="white",xlab="",ylab="")
for(i in 1:k){
train <- data[unlist(folds[-i]),]
test <- data[unlist(folds[i]),]
fit <- glm(formula, data=train, family = "binomial")
fit.probs <- predict(fit, newdata = test, type = "response")
lines(ROC(fit.probs, test[,"complaint"])$roc,type="s",col=CL[i])
}
}
plot.CV.ROC.curve(complaint~sentiment, scores, 10)
library(RColorBrewer)
CL=brewer.pal(8, "Set1")[-7]
CL=brewer.pal(10, "Set1")
CL=brewer.pal(9, "Set1")
plot.CV.ROC.curve(complaint~sentiment, scores, 9)
plot.CV.ROC.curve = function(formula, data, k){
folds <- createFolds(1:nrow(data), k)
plot(0:1,0:1,col="white",xlab="",ylab="")
for(i in 1:k){
train <- data[unlist(folds[-i]),]
test <- data[unlist(folds[i]),]
fit <- glm(formula, data=train, family = "binomial")
fit.probs <- predict(fit, newdata = test, type = "response")
lines(ROC(fit.probs, test[,"complaint"])$roc,type="l",col=CL[i])
}
}
plot.CV.ROC.curve(complaint~sentiment, scores, 9)
plot.CV.ROC.curve = function(formula, data, k){
folds <- createFolds(1:nrow(data), k)
plot(0:1,0:1,col="white",xlab="",ylab="")
auc <- rep(0, k)
for(i in 1:k){
train <- data[unlist(folds[-i]),]
test <- data[unlist(folds[i]),]
fit <- glm(formula, data=train, family = "binomial")
fit.probs <- predict(fit, newdata = test, type = "response")
cur <- ROC(fit.probs, test[,"complaint"])
lines(cur$roc,type="l",col=CL[i])
auc[i] <- cur$auc
}
title("Mean AUC: " + mean(auc))
}
plot.CV.ROC.curve(complaint~sentiment, scores, 9)
plot.CV.ROC.curve = function(formula, data, k){
folds <- createFolds(1:nrow(data), k)
plot(0:1,0:1,col="white",xlab="",ylab="")
auc <- rep(0, k)
for(i in 1:k){
train <- data[unlist(folds[-i]),]
test <- data[unlist(folds[i]),]
fit <- glm(formula, data=train, family = "binomial")
fit.probs <- predict(fit, newdata = test, type = "response")
cur <- ROC(fit.probs, test[,"complaint"])
lines(cur$roc,type="l",col=CL[i])
auc[i] <- cur$auc
}
title("Mean AUC: " + str(mean(auc)))
}
plot.CV.ROC.curve(complaint~sentiment, scores, 9)
title(main = paste0("Mean AUC: ", mean(auc)))
plot.CV.ROC.curve = function(formula, data, k){
folds <- createFolds(1:nrow(data), k)
plot(0:1,0:1,col="white",xlab="",ylab="")
auc <- rep(0, k)
for(i in 1:k){
train <- data[unlist(folds[-i]),]
test <- data[unlist(folds[i]),]
fit <- glm(formula, data=train, family = "binomial")
fit.probs <- predict(fit, newdata = test, type = "response")
cur <- ROC(fit.probs, test[,"complaint"])
lines(cur$roc,type="l",col=CL[i])
auc[i] <- cur$auc
}
title(main = paste0("Mean AUC: ", mean(auc)))
}
plot.CV.ROC.curve(complaint~sentiment, scores, 9)
plot.CV.ROC.curve(complaint~sentiment, scores, 5)
plot.CV.ROC.curve = function(formula, data, k){
folds <- createFolds(1:nrow(data), k)
plot(0:1,0:1,col="white",xlab="",ylab="")
auc <- rep(0, k)
for(i in 1:k){
train <- data[unlist(folds[-i]),]
test <- data[unlist(folds[i]),]
fit <- glm(formula, data=train, family = "binomial")
fit.probs <- predict(fit, newdata = test, type = "response")
cur <- ROC(fit.probs, test[,"complaint"])
lines(cur$roc,type="s",col=CL[i])
auc[i] <- cur$auc
}
title(main = paste0("Mean AUC: ", mean(auc)))
}
plot.CV.ROC.curve(complaint~sentiment, scores, 5)
